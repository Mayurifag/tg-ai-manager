{% extends "base.html" %}

{% block title %}
{% if chat %}
{{ chat.name }}
{% else %}
Messages
{% endif %}
{% endblock %}

{% block head_extra %}
<link rel="stylesheet" href="/static/css/chat_styles.css?v={{ range(1, 10000) | random }}">
{% endblock %}

{% block content %}
<div class="header">
    <a href="javascript:history.back()" class="back-link">‚Üê Back</a>
    {% if chat %}
    <span style="font-weight: bold; margin-left: 10px;">{{ chat.name }}</span>
    {% endif %}
</div>

<!--
    messages-container uses flex-direction: column-reverse.
    Visually: Top of screen = End of HTML list. Bottom of screen = Start of HTML list.
    Wait, usually column-reverse means:
    Top of visual container has the LAST element in the DOM.
    Bottom of visual container has the FIRST element in the DOM.

    Telethon returns [Newest, ..., Oldest].
    If we iterate normally:
    1. Newest
    2. Older

    Visual (Column-Reverse):
    2. Older (Top)
    1. Newest (Bottom)

    This matches standard chat behavior (newest at bottom).

    To load older messages (history), we need to append them to the END of the DOM list (which is the VISUAL TOP).
-->
<div class="messages-container" id="messages-container">
    {% include "chat/messages_partial.html" %}
</div>

<!-- Loading spinner (hidden by default) -->
<div id="loading-indicator" style="display: none; text-align: center; padding: 10px; color: #666;">
    Loading...
</div>

<script>
    const container = document.getElementById('messages-container');
    const chatId = {{ chat_id }};
    const topicId = {{ topic_id or 'null' }};
    let isLoading = false;
    let allLoaded = false;

    // Scroll to bottom on initial load
    // With column-reverse, scrollTop = 0 is actually the "bottom" visually if content overflows?
    // No, browsers handle reverse flex containers oddly regarding scroll.
    // Usually, with column-reverse, scrollTop 0 is at the physical top (which is the oldest message).
    // We want to be at the physical bottom (newest message).
    // Let's reset logic:
    // Standard approach: To see newest messages, we usually scroll to bottom.
    // Let's rely on window scroll.

    // Actually, looking at the CSS: .messages-container { display: flex; flex-direction: column-reverse; }
    // This reverses the order of children.
    //
    // Logic for Infinite Scroll (Upwards):
    // As we scroll UP (visual top), we approach the bottom of the DOM list (because it's reversed).
    // So we need to detect when we are near the 'bottom' of the container element physically?
    // Or just use window scroll?
    //
    // Let's assume the container fills the page.
    // Visual Top = Physical Top of window.
    // We want to load when user scrolls to Top.

    window.scrollTo(0, document.body.scrollHeight);

    window.addEventListener('scroll', () => {
        if (isLoading || allLoaded) return;

        // Detect if scrolled to top
        if (window.scrollY < 100) {
            loadOlderMessages();
        }
    });

    async function loadOlderMessages() {
        isLoading = true;
        const indicator = document.getElementById('loading-indicator');
        indicator.style.display = 'block';

        // Find the ID of the oldest message (visually top, so physically last in DOM list)
        const messages = container.querySelectorAll('.message-row');
        if (messages.length === 0) {
            isLoading = false;
            return;
        }

        const oldestMsg = messages[messages.length - 1];
        const offsetId = oldestMsg.getAttribute('data-id');

        // Save scroll height before appending
        const previousHeight = document.body.scrollHeight;

        try {
            let url = `/api/chat/${chatId}/history?offset_id=${offsetId}`;
            if (topicId) url += `&topic_id=${topicId}`;

            const response = await fetch(url);
            const data = await response.json();

            if (data.count === 0) {
                allLoaded = true;
            } else {
                // Append new messages to the end of the container (Visual Top)
                container.insertAdjacentHTML('beforeend', data.html);

                // Adjust scroll position to maintain view
                const newHeight = document.body.scrollHeight;
                window.scrollTo(0, newHeight - previousHeight);
            }
        } catch (error) {
            console.error('Failed to load history:', error);
        } finally {
            isLoading = false;
            indicator.style.display = 'none';
        }
    }
</script>
{% endblock %}
