{% extends "base.html.j2" %}
{% import "macros/chat_card.html.j2" as cards %}

{% block head_extra %}
<link rel="stylesheet" href="/static/css/chat_list.css">
<link rel="stylesheet" href="/static/css/index_styles.css">
{% endblock %}

{% block sidebar_back %}
{% endblock %}

{% block settings %}
{% endblock %}

{% block content %}
<div class="chat-list" id="chat-list-container">
    {% for chat in chats %}
    <div class="chat-card-wrapper" data-chat-id="{{ chat.id }}" {% if chat.is_pinned %}data-is-pinned="true" {% endif
        %}>
        {{ cards.render_chat_card(chat) }}
    </div>
    {% endfor %}
</div>

<script>
    let updateTimeouts = {};

    async function reloadCard(chatId) {
        if (!chatId) return;

        // Debounce to handle multiple deletes at once
        if (updateTimeouts[chatId]) clearTimeout(updateTimeouts[chatId]);

        // Wait 500ms to allow Telegram servers to process the deletion state
        updateTimeouts[chatId] = setTimeout(async () => {
            const list = document.getElementById('chat-list-container');
            const cardWrapper = list.querySelector(`.chat-card-wrapper[data-chat-id="${chatId}"]`);

            try {
                // Fetch the new card HTML
                const response = await fetch(`/api/chat/${chatId}/card?t=${Date.now()}`);
                if (response.ok) {
                    const html = await response.text();

                    // Create a temporary element to hold the new card wrapper
                    const temp = document.createElement('div');
                    temp.innerHTML = html;
                    const newCard = temp.firstElementChild; // The new div.chat-card-wrapper
                    const isPinned = newCard.getAttribute('data-is-pinned') === 'true';

                    if (cardWrapper) {
                        // Replace existing card
                        cardWrapper.replaceWith(newCard);
                    } else {
                        // New Chat: Insert after pinned chats (or at top if pinned)
                        const pinnedChats = list.querySelectorAll('.chat-card-wrapper[data-is-pinned="true"]');
                        let insertionPoint;

                        if (isPinned || pinnedChats.length === 0) {
                            // If new chat is pinned OR there are no pinned chats, insert at the top
                            insertionPoint = list.firstChild;
                        } else {
                            // If new chat is unpinned, insert after the last pinned chat
                            insertionPoint = pinnedChats[pinnedChats.length - 1].nextSibling;
                        }

                        list.insertBefore(newCard, insertionPoint);
                    }

                    // Visual Highlight
                    const inner = newCard.querySelector('.chat-card');
                    if (inner) {
                        inner.style.transition = 'background-color 0.5s';
                        inner.style.backgroundColor = '#fff9c4';
                        setTimeout(() => inner.style.backgroundColor = '', 800);
                    }
                }
            } catch (e) {
                console.error("Error updating card:", e);
            }
        }, 500);
    }

    document.addEventListener('tg:event', async (e) => {
        const data = e.detail;

        // If chat_id is missing, we can't do anything (though backend now tries hard to find it)
        if (!data.chat_id) return;

        if (data.type === 'message') {
            const list = document.getElementById('chat-list-container');
            const cardWrapper = list.querySelector(`.chat-card-wrapper[data-chat-id="${data.chat_id}"]`);

            // If card exists and is NOT a forum, we can try a fast client-side update
            let isForum = false;
            if (cardWrapper) {
                const innerLink = cardWrapper.querySelector('.chat-card');
                if (innerLink && innerLink.getAttribute('data-chat-type') === 'forum') isForum = true;
            }

            if (cardWrapper && !isForum) {
                // Client-side optimizations
                const previewEl = cardWrapper.querySelector('.preview');
                if (previewEl) previewEl.textContent = data.text;

                const chatCard = cardWrapper.querySelector('.chat-card');
                let unreadBadge = chatCard.querySelector('.unread');

                if (unreadBadge) {
                    let count = parseInt(unreadBadge.textContent);
                    if (!isNaN(count)) unreadBadge.textContent = count + 1;
                } else {
                    let metaDiv = chatCard.querySelector('.meta');
                    if (!metaDiv) {
                        metaDiv = document.createElement('div');
                        metaDiv.className = 'meta';
                        chatCard.appendChild(metaDiv);
                    }
                    const newBadge = document.createElement('div');
                    newBadge.className = 'unread';
                    newBadge.textContent = '1';
                    metaDiv.appendChild(newBadge);
                }

                // NEW LOGIC: Only move if it is NOT pinned. Pinned chats stay put.
                const isPinned = cardWrapper.getAttribute('data-is-pinned') === 'true';
                if (!isPinned) {
                    // Move the cardWrapper after the last pinned chat (to the top of the unpinned list)
                    const pinnedChats = list.querySelectorAll('.chat-card-wrapper[data-is-pinned="true"]');
                    const insertionPoint = pinnedChats.length > 0 ? pinnedChats[pinnedChats.length - 1].nextSibling : list.firstChild;
                    list.insertBefore(cardWrapper, insertionPoint);
                }

                cardWrapper.style.transition = 'background-color 0.5s';
                cardWrapper.style.backgroundColor = '#e3f2fd';
                setTimeout(() => cardWrapper.style.backgroundColor = '', 1000);
            } else {
                // Forums or New Chats: Must reload card from server
                await reloadCard(data.chat_id);
            }
        }
        else if (data.type === 'deleted' || data.type === 'edited') {
            // ALWAYS reload card from server on delete/edit
            await reloadCard(data.chat_id);
        }
    });
</script>
{% endblock %}
