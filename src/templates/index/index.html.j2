{% extends "base.html.j2" %}
{% import "macros/chat_card.html.j2" as cards %}

{% block head_extra %}
<link rel="stylesheet" href="/static/css/chat_list.css?t={{ 'static/css/chat_list.css' | file_mtime }}">
<link rel="stylesheet" href="/static/css/index_styles.css?t={{ 'static/css/index_styles.css' | file_mtime }}">
{% endblock %}

{% block sidebar_back %}
{% endblock %}

{% block settings %}
{% endblock %}

{% block content %}
<div class="chat-list" id="chat-list-container">
    {% for chat in chats %}
    <div class="chat-card-wrapper" data-chat-id="{{ chat.id }}" {% if chat.is_pinned %}data-is-pinned="true" {% endif
        %}>
        {{ cards.render_chat_card(chat) }}
    </div>
    {% endfor %}
</div>

<script>
    // Handle Mark as Read clicks
    document.getElementById('chat-list-container').addEventListener('click', async (e) => {
        if (e.target.classList.contains('mark-read-btn')) {
            e.preventDefault();
            e.stopPropagation();

            const btn = e.target;
            const chatId = btn.getAttribute('data-chat-id');
            const topicId = btn.getAttribute('data-topic-id') || null;

            if (!chatId) return;

            btn.style.opacity = '0.5';
            btn.style.pointerEvents = 'none';

            try {
                const response = await fetch(`/api/chat/${chatId}/read`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ topic_id: topicId })
                });

                if (response.ok) {
                    // Visually update the card: remove unread badge and button
                    const card = btn.closest('.chat-card');
                    if (card) {
                        const unread = card.querySelector('.unread');
                        if (unread) unread.remove();
                        btn.remove();
                    }
                }
            } catch (err) {
                console.error("Error marking as read:", err);
                btn.style.opacity = '1';
                btn.style.pointerEvents = 'auto';
            }
        }
    });

    let updateTimeouts = {};

    async function reloadCard(chatId) {
        if (!chatId) return;

        if (updateTimeouts[chatId]) clearTimeout(updateTimeouts[chatId]);

        updateTimeouts[chatId] = setTimeout(async () => {
            const list = document.getElementById('chat-list-container');
            const cardWrapper = list.querySelector(`.chat-card-wrapper[data-chat-id="${chatId}"]`);

            try {
                const response = await fetch(`/api/chat/${chatId}/card?t=${Date.now()}`);
                if (response.ok) {
                    const html = await response.text();

                    const temp = document.createElement('div');
                    temp.innerHTML = html;
                    const newCard = temp.firstElementChild;
                    const isPinned = newCard.getAttribute('data-is-pinned') === 'true';

                    if (cardWrapper) {
                        cardWrapper.replaceWith(newCard);
                    } else {
                        const pinnedChats = list.querySelectorAll('.chat-card-wrapper[data-is-pinned="true"]');
                        let insertionPoint;

                        if (isPinned || pinnedChats.length === 0) {
                            insertionPoint = list.firstChild;
                        } else {
                            insertionPoint = pinnedChats[pinnedChats.length - 1].nextSibling;
                        }

                        list.insertBefore(newCard, insertionPoint);
                    }

                    const inner = newCard.querySelector('.chat-card');
                    if (inner) {
                        inner.style.transition = 'background-color 0.5s';
                        inner.style.backgroundColor = '#fff9c4';
                        setTimeout(() => inner.style.backgroundColor = '', 800);
                    }
                }
            } catch (e) {
                console.error("Error updating card:", e);
            }
        }, 500);
    }

    document.addEventListener('tg:event', async (e) => {
        const data = e.detail;

        if (!data.chat_id) return;

        // Handle Read events (from API or Startup Scan)
        if (data.type === 'read') {
            await reloadCard(data.chat_id);
            return;
        }

        if (data.type === 'message') {
            const list = document.getElementById('chat-list-container');
            const cardWrapper = list.querySelector(`.chat-card-wrapper[data-chat-id="${data.chat_id}"]`);

            let isForum = false;
            if (cardWrapper) {
                const innerLink = cardWrapper.querySelector('.chat-card');
                if (innerLink && innerLink.getAttribute('data-chat-type') === 'forum') isForum = true;
            }

            if (cardWrapper && !isForum) {
                const previewEl = cardWrapper.querySelector('.preview');
                // FIX: Use innerHTML to render bold/italic tags correctly
                if (previewEl) previewEl.innerHTML = data.text;

                const chatCard = cardWrapper.querySelector('.chat-card');

                // --- Logic Update for is_read ---
                if (!data.is_read) {
                    let unreadBadge = chatCard.querySelector('.unread');
                    if (unreadBadge) {
                        let count = parseInt(unreadBadge.textContent);
                        if (!isNaN(count)) unreadBadge.textContent = count + 1;
                    } else {
                        let metaDiv = chatCard.querySelector('.meta');
                        if (!metaDiv) {
                            metaDiv = document.createElement('div');
                            metaDiv.className = 'meta';
                            chatCard.appendChild(metaDiv);
                        }
                        const newBadge = document.createElement('div');
                        newBadge.className = 'unread';
                        newBadge.textContent = '1';
                        metaDiv.appendChild(newBadge);
                    }
                }

                const isPinned = cardWrapper.getAttribute('data-is-pinned') === 'true';
                if (!isPinned) {
                    const pinnedChats = list.querySelectorAll('.chat-card-wrapper[data-is-pinned="true"]');
                    const insertionPoint = pinnedChats.length > 0 ? pinnedChats[pinnedChats.length - 1].nextSibling : list.firstChild;
                    list.insertBefore(cardWrapper, insertionPoint);
                }

                cardWrapper.style.transition = 'background-color 0.5s';
                cardWrapper.style.backgroundColor = '#e3f2fd';
                setTimeout(() => cardWrapper.style.backgroundColor = '', 1000);
            } else {
                await reloadCard(data.chat_id);
            }
        }
        else if (data.type === 'deleted' || data.type === 'edited') {
            await reloadCard(data.chat_id);
        }
    });
</script>
{% endblock %}
